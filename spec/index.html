<html><head><meta content="text/html; charset=UTF-8" http-equiv="content-type"><style type="text/css">ul.lst-kix_bmrobk6u7wxi-6{list-style-type:none}.lst-kix_bmrobk6u7wxi-8>li:before{content:"\0025a0   "}ul.lst-kix_bmrobk6u7wxi-7{list-style-type:none}ul.lst-kix_bmrobk6u7wxi-4{list-style-type:none}ul.lst-kix_bmrobk6u7wxi-5{list-style-type:none}ul.lst-kix_bmrobk6u7wxi-2{list-style-type:none}.lst-kix_bmrobk6u7wxi-6>li:before{content:"\0025cf   "}.lst-kix_xgex1lihlllv-7>li:before{content:"\0025cb   "}.lst-kix_xgex1lihlllv-8>li:before{content:"\0025a0   "}ul.lst-kix_bmrobk6u7wxi-3{list-style-type:none}ul.lst-kix_bmrobk6u7wxi-0{list-style-type:none}.lst-kix_bmrobk6u7wxi-5>li:before{content:"\0025a0   "}ul.lst-kix_bmrobk6u7wxi-1{list-style-type:none}.lst-kix_xgex1lihlllv-5>li:before{content:"\0025a0   "}.lst-kix_xgex1lihlllv-6>li:before{content:"\0025cf   "}.lst-kix_bmrobk6u7wxi-7>li:before{content:"\0025cb   "}ul.lst-kix_bmrobk6u7wxi-8{list-style-type:none}.lst-kix_bmrobk6u7wxi-0>li:before{content:"\0025cf   "}.lst-kix_xgex1lihlllv-1>li:before{content:"\0025cb   "}.lst-kix_xgex1lihlllv-2>li:before{content:"\0025a0   "}.lst-kix_bmrobk6u7wxi-2>li:before{content:"\0025a0   "}.lst-kix_xgex1lihlllv-0>li:before{content:"\0025cf   "}.lst-kix_xgex1lihlllv-3>li:before{content:"\0025cf   "}.lst-kix_xgex1lihlllv-4>li:before{content:"\0025cb   "}.lst-kix_bmrobk6u7wxi-1>li:before{content:"\0025cb   "}.lst-kix_bmrobk6u7wxi-4>li:before{content:"\0025cb   "}.lst-kix_bmrobk6u7wxi-3>li:before{content:"\0025cf   "}li.li-bullet-0:before{margin-left:-18pt;white-space:nowrap;display:inline-block;min-width:18pt}ul.lst-kix_xgex1lihlllv-4{list-style-type:none}ul.lst-kix_xgex1lihlllv-3{list-style-type:none}ul.lst-kix_xgex1lihlllv-6{list-style-type:none}ul.lst-kix_xgex1lihlllv-5{list-style-type:none}ul.lst-kix_xgex1lihlllv-8{list-style-type:none}ul.lst-kix_xgex1lihlllv-7{list-style-type:none}ul.lst-kix_xgex1lihlllv-0{list-style-type:none}ul.lst-kix_xgex1lihlllv-2{list-style-type:none}ul.lst-kix_xgex1lihlllv-1{list-style-type:none}ol{margin:0;padding:0}table td,table th{padding:0}.c13{padding-top:18pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c1{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Courier New";font-style:normal}.c8{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:16pt;font-family:"Times New Roman";font-style:normal}.c27{padding-top:0pt;padding-bottom:16pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c0{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left;height:12pt}.c6{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Times New Roman";font-style:normal}.c26{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:15pt;font-family:"Times New Roman";font-style:normal}.c20{padding-top:16pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c10{color:#434343;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:14pt;font-family:"Times New Roman";font-style:normal}.c7{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:20pt;font-family:"Courier New";font-style:normal}.c15{color:#666666;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c28{padding-top:0pt;padding-bottom:3pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c11{padding-top:14pt;padding-bottom:4pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c17{padding-top:20pt;padding-bottom:6pt;line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.c3{color:#000000;font-weight:400;text-decoration:none;vertical-align:baseline;font-size:12pt;font-family:"Times New Roman";font-style:normal}.c24{padding-top:0pt;padding-bottom:0pt;line-height:1.0;orphans:2;widows:2;text-align:left}.c25{color:#000000;text-decoration:none;vertical-align:baseline;font-size:26pt;font-family:"Times New Roman";font-style:normal}.c2{padding-top:0pt;padding-bottom:0pt;line-height:1.15;orphans:2;widows:2;text-align:left}.c23{background-color:#ffffff;max-width:468pt;padding:72pt 72pt 72pt 72pt}.c16{font-weight:400;font-family:"Courier New"}.c19{padding:0;margin:0}.c18{width:33%;height:1px}.c12{padding-left:0pt}.c21{text-indent:36pt}.c4{font-style:italic}.c9{margin-left:36pt}.c5{font-weight:700}.c22{vertical-align:super}.c14{font-size:10pt}.title{padding-top:0pt;color:#000000;font-weight:700;font-size:26pt;padding-bottom:3pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}.subtitle{padding-top:0pt;color:#666666;font-size:15pt;padding-bottom:16pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}li{color:#000000;font-size:12pt;font-family:"Times New Roman"}p{margin:0;color:#000000;font-size:12pt;font-family:"Times New Roman"}h1{padding-top:20pt;color:#000000;font-size:20pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h2{padding-top:18pt;color:#000000;font-size:16pt;padding-bottom:6pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h3{padding-top:16pt;color:#434343;font-size:14pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h4{padding-top:14pt;color:#666666;font-size:12pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h5{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;orphans:2;widows:2;text-align:left}h6{padding-top:12pt;color:#666666;font-size:11pt;padding-bottom:4pt;font-family:"Times New Roman";line-height:1.15;page-break-after:avoid;font-style:italic;orphans:2;widows:2;text-align:left}</style></head><body class="c23 doc-content"><p class="c28 title" id="h.r5e1ytn316q0"><span class="c5 c25">The Gorr Specification Language</span></p><p class="c27 subtitle" id="h.m6s1l2vp4k50"><span>version 0 by Kyle Williams - June 2</span><span class="c22">nd</span><span class="c26">, 2023</span></p><h1 class="c17" id="h.25t6krweagn7"><span class="c6">Introduction</span></h1><p class="c2"><span class="c4">Gorr </span><span>(a sorry pun on al-</span><span class="c4">gor</span><span class="c3">-ithm) is a formal natural specification language. It is meant to guide software development, allowing one to focus on defining behavior instead of implementation. In contrast to previous formal specification languages, Gorr&rsquo;s syntax is entirely rooted in English; this is done in the hopes that specifications written in Gorr can be parsed by those with little or no specification experience.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">What follows this introductory section is a description of the language&rsquo;s features alongside a grammar written in Extended Backus-Naur Form (EBNF) and two example specifications.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">To understand this document, it is recommended that one have some familiarity with arithmetic and computer programming.</span></p><h2 class="c13" id="h.do30hkvcik2"><span>Introduction to Extended Backus-Naur Form (EBNF)</span></h2><p class="c2"><span>A grammar written in EBNF consists of a series of </span><span class="c4">rules</span><span>. Each rule&rsquo;s job is to scan a piece of text for a defined </span><span class="c4">pattern</span><span>, which itself is a sequence of </span><span class="c4">symbols</span><span>. A piece of text is </span><span class="c4">valid</span><span>&nbsp;according to the grammar if the text can be matched by the pattern of the </span><span class="c4">top-level rule</span><span class="c3">&nbsp;of the grammar.</span></p><p class="c0"><span class="c3"></span></p><p class="c2 c9"><span class="c1">&#10216;rule name&#10217; &rarr; &#10216;pattern of rule&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">The base symbol of EBNF is the string, which represents matching the series of characters in between a string&rsquo;s pair of quotes.</span></p><p class="c0"><span class="c3"></span></p><p class="c2 c9"><span class="c16">&ldquo;ban&rdquo;</span><span class="c3">&nbsp;matches the text &ldquo;ban&rdquo; but not &ldquo;bat&rdquo; or &ldquo;banner&rdquo;.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>There are two special character sequences that can show up in a string to represent matching a character that normally can&rsquo;t be seen: </span><span class="c16">&ldquo;\t&rdquo;</span><span>&nbsp;matches the tab (&ldquo;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&rdquo;) and </span><span class="c16">&ldquo;\n&rdquo;</span><span class="c3">&nbsp;matches the beginning of a new line.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>Multiple symbols can be referenced in one pattern putting a space between each symbol; note that the space does not become part of the rule. Rules can be referenced in other rules by writing the name of the rule between two angle brackets (</span><span class="c16">&#10216; &#10217;</span><span class="c3">).</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">&#10216;ban&#10217; &rarr; &ldquo;ban&rdquo;;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;banner&#10217; &rarr; &#10216;ban&#10217; &ldquo;ner&rdquo;;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span></p><p class="c2"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;banner&#10217;</span><span class="c3">&nbsp;matches &ldquo;banner&rdquo; but not &ldquo;ban&rdquo; or &ldquo;ban ner&rdquo;.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>Multiple symbols can be combined into one symbol by encasing them in parentheses (</span><span class="c16">( )</span><span class="c3">). The following two rules are equivalent:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;hello&#10217; &rarr; &ldquo;hello&rdquo; &ldquo;world&rdquo;;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;hello&#10217; &rarr; (&ldquo;hello&rdquo; &ldquo;world&rdquo;);</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The matching behavior of symbols can be modified with </span><span class="c4">operators</span><span>. The union operator, marked by the pipe (</span><span class="c16">|</span><span class="c3">), can be used to say the matching of two or more patterns is valid.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">&#10216;digit&#10217; &rarr; &ldquo;0&rdquo; | &ldquo;1&rdquo; | &ldquo;2&rdquo; | &ldquo;3&rdquo; | &ldquo;4&rdquo; | &ldquo;5&rdquo; | &ldquo;6&rdquo; | &ldquo;7&rdquo; | &ldquo;8&rdquo; | &ldquo;9&rdquo;;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c16">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;digit&#10217;</span><span class="c3">&nbsp;matches &ldquo;0&rdquo;, &ldquo;5&rdquo;, and &ldquo;9&rdquo;, but not &ldquo;a&rdquo; or &ldquo;9ban&rdquo; or &ldquo;99&rdquo;.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The optional operator, marked by the question mark (</span><span class="c16">?</span><span>), is equivalent to creating a union between a symbol or an empty string (</span><span class="c16">&ldquo;&rdquo;</span><span class="c3">). The following two rules are equivalent:</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;goodbye&#10217; &rarr; &ldquo;goodbye&rdquo; &ldquo;world&rdquo;?;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;goodbye&#10217; &rarr; &ldquo;goodbye&rdquo; (&ldquo;world&rdquo; | &ldquo;&rdquo;);</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">The one or more operator, marked by the plus (+), enables a symbol can be matched one or more times.</span></p><p class="c0"><span class="c3"></span></p><p class="c2 c9"><span class="c1">&#10216;aaaaah&#10217; &rarr; &ldquo;a&rdquo;+ &ldquo;h&rdquo;;</span></p><p class="c0 c9"><span class="c1"></span></p><p class="c2 c9"><span class="c16">&#10216;aaaaah&#10217;</span><span class="c3">&nbsp;matches &ldquo;ah&rdquo;, &ldquo;aaaaaaaaaaaaaaaah&rdquo;, and &ldquo;aaaaah&rdquo;.</span></p><p class="c0 c9"><span class="c3"></span></p><p class="c2"><span>The zero or more operator, marked by the asterisk (</span><span class="c16">*</span><span class="c3">), is equivalent to combining the one or more and optional operators. The following two rules are equivalent:<br></span></p><p class="c2"><span>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;</span><span class="c1">&#10216;inputs&#10217; &rarr; (&ldquo;a&rdquo; | &ldquo;b&rdquo; | &ldquo;x&rdquo; | &ldquo;y&rdquo;)*;</span></p><p class="c2"><span class="c1">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&#10216;inputs&#10217; &rarr; ((&ldquo;a&rdquo; | &ldquo;b&rdquo; | &ldquo;x&rdquo; | &ldquo;y&rdquo;)+)?;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>There is one more kind of symbol: a special sequence, arbitrary text enclosed between two question marks (</span><span class="c16">? ?</span><span>), can be used to define a pattern that would be challenging to describe in EBNF.</span></p><h1 class="c17" id="h.tu5vs9fybfn9"><span>Description &amp; Grammar</span></h1><h2 class="c13" id="h.s8c0b26ksosl"><span class="c8">A Map of the Language</span></h2><p class="c2"><span style="overflow: hidden; display: inline-block; margin: 0.00px 0.00px; border: 0.00px solid #000000; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px); width: 610.50px; height: 192.88px;"><img alt="" src="images/image1.png" style="width: 610.50px; height: 192.88px; margin-left: 0.00px; margin-top: 0.00px; transform: rotate(0.00rad) translateZ(0px); -webkit-transform: rotate(0.00rad) translateZ(0px);" title=""></span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">The above map is a dependency graph of concepts in the Gorr language created from its grammar. Concepts point towards other concepts they rely on. Some dependencies are cyclical; for example, binary operators are a kind of expression, but they themselves rely on the existence of expressions, &nbsp;otherwise, you wouldn&rsquo;t be able to nest operations and other expressions inside of them.</span></p><h2 class="c13" id="h.7mbsk8zekrvv"><span class="c8">Grammar</span></h2><p class="c2"><span>In order for a Gorr specification to be valid, it </span><span class="c5">must</span><span>&nbsp;follow the EBNF grammar described in the latter sections of this description.</span></p><h2 class="c13" id="h.jrlctueexufl"><span class="c8">Utility Rules</span></h2><p class="c2"><span class="c1">&#10216;space&#10217; &rarr; (&ldquo; &ldquo; | &ldquo;\t&rdquo;)+;</span></p><p class="c2"><span class="c1">&#10216;newline&#10217; &rarr; &ldquo;\n&rdquo;;</span></p><p class="c2"><span class="c1">&#10216;period&#10217; &rarr; &ldquo;.&rdquo;;</span></p><p class="c2"><span class="c1">&#10216;comma&#10217; &rarr; &ldquo;,&rdquo;</span></p><h2 class="c13" id="h.202ziadp8may"><span class="c8">Standard Data Types</span></h2><p class="c2"><span class="c1">&#10216;digit&#10217; &rarr; &ldquo;0&rdquo; | &ldquo;1&rdquo; | &ldquo;2&rdquo; | &ldquo;3&rdquo; | &ldquo;4&rdquo; | &ldquo;5&rdquo; | &ldquo;6&rdquo; | &ldquo;7&rdquo; | &ldquo;8&rdquo; | &ldquo;9&rdquo;;</span></p><p class="c2"><span class="c1">&#10216;integer&#10217; &rarr; &ldquo;-&rdquo;? &#10216;digit&#10217;+;</span></p><p class="c2"><span class="c1">&#10216;boolean&#10217; &rarr; &ldquo;true&rdquo; | &ldquo;false&rdquo;;</span></p><p class="c2"><span class="c1">&#10216;value&#10217; &rarr; &#10216;integer&#10217; | &#10216;boolean&#10217;;</span></p><p class="c2"><span class="c1">&#10216;data type&#10217; &rarr; &ldquo;integer&rdquo; | &ldquo;Boolean&rdquo;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>Gorr has two </span><span class="c4">standard data types</span><sup class="c4"><a href="#ftnt1" id="ftnt_ref1">[1]</a></sup><span>: the integer and the Boolean. Data types can be manipulated by </span><span class="c4">operators</span><span>.</span></p><h2 class="c13" id="h.9th22b4ex8ob"><span class="c8">Specification</span></h2><p class="c2"><span class="c1">&#10216;specification&#10217; &rarr; &#10216;statement&#10217;+;</span></p><p class="c2"><span class="c1">&#10216;statement&#10217; &rarr; (&#10216;variable declaration&#10217; | &#10216;algorithm declaration&#10217;) &#10216;newline&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">A specification written in Gorr is a series of statements, either variable or algorithm declarations.</span></p><h2 class="c13" id="h.3my9fw84lq3r"><span class="c8">Variables</span></h2><p class="c2"><span class="c1">&#10216;variable&#10217; &rarr; &ldquo;[[&rdquo; &#10216;space&#10217;? &#10216;text&#10217; &#10216;space&#10217;? &ldquo;]]&rdquo;;</span></p><p class="c2"><span class="c1">&#10216;variable declaration&#10217; &rarr; &ldquo;The&rdquo; &#10216;space&#10217; &#10216;data type&#10217; &#10216;space&#10217; &#10216;variable&#10217; &#10216;space&#10217; &ldquo;is&rdquo; &#10216;expression&#10217; &#10216;period&#10217;;</span></p><p class="c2"><span class="c1">&#10216;variable assignment&#10217; &rarr; &ldquo;Set&rdquo; &#10216;space&#10217; &#10216;variable&#10217; &#10216;space&#10217; &ldquo;to&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;period&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Variables in Gorr can be used to store and retrieve values. The value of a variable can be changed with an assignment.</span></p><p class="c2"><span>When declaring a variable, one </span><span class="c5">must</span><span class="c3">&nbsp;give it a name, a type, and an initial expression that evaluates to a value of that.</span></p><p class="c2"><span>When assigning a value to a variable, the expression given </span><span class="c5">must</span><span class="c3">&nbsp;match the type of the variable.</span></p><p class="c2"><span>Variables declared at the top of a specification are </span><span class="c4">constants</span><span>, and </span><span class="c5">cannot</span><span class="c3">&nbsp;be modified with an &nbsp;assignment after declaration.</span></p><h3 class="c20" id="h.wp8r4ktokb3e"><span class="c10">Scope</span></h3><p class="c2"><span>When a variable is declared, it </span><span class="c4">enters</span><span>&nbsp;</span><span class="c4">scope,</span><span>&nbsp;and a variable with the same name </span><span class="c5">cannot</span><span>&nbsp;be declared again until it </span><span class="c4">exits </span><span class="c3">scope. A variable exits scope when:</span></p><ul class="c19 lst-kix_xgex1lihlllv-0 start"><li class="c2 c12 c9 li-bullet-0"><span class="c3">The algorithm it is declared in ends.</span></li><li class="c2 c9 c12 li-bullet-0"><span class="c3">The control flow block it is declared in ends.</span></li></ul><p class="c0"><span class="c3"></span></p><p class="c2"><span>Constants </span><span class="c5">never</span><span class="c3">&nbsp;exit scope.</span></p><p class="c2"><span>Variables </span><span class="c5">cannot</span><span class="c3">&nbsp;be referenced in assignments or expressions before they enter scope.</span></p><h2 class="c13" id="h.xgjrc6csym14"><span class="c8">Algorithms</span></h2><p class="c2"><span class="c1">&#10216;algorithm declaration&#10217; &rarr; &ldquo;The algorithm&rdquo; &#10216;space&#10217; &#10216;variable&#10217; &#10216;space&#10217; &#10216;comma&#10217;</span></p><p class="c2"><span class="c1">(* Arguments*)</span></p><p class="c2"><span class="c1">&ldquo;with the signature&rdquo; ( &#10216;data type&#10217; &#10216;space&#10217; &#10216;variable&#10217; (&#10216;comma&#10217; &#10216;space&#10217; &#10216;data type&#10217; &#10216;space&#10217; &#10216;variable&#10217;)*)? &ldquo;returns&rdquo; (&#10216;data type&#10217; | &ldquo;void&rdquo;) &#10216;comma&#10217;</span></p><p class="c2"><span class="c1">&ldquo;does the following:&rdquo; &#10216;newline&#10217;</span></p><p class="c2"><span class="c1">(* Body *)</span></p><p class="c2"><span class="c1">(&lt;space&gt;? &#10216;digit&#10217;+ (&#10216;period&#10217; &#10216;digit&#10217;)* &#10216;period&#10217; &#10216;space&#10217; &#10216;algorithm statement&#10217; &#10216;newline&#10217;)+;</span></p><p class="c2"><span class="c1">&#10216;algorithm statement&#10217; &rarr; &#10216;if&#10217; | &#10216;otherwise&#10217; | &#10216;while&#10217; | &#10216;return&#10217; | &#10216;variable declaration&#10217; | &#10216;variable assignment&#10217; | &#10216;discard&#10217; | &#10216;pass&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c4">Algorithms</span><span>&nbsp;are the core unit of Gorr; they are used to specify and encapsulate chunks of logic. An algorithm has a name, an optional series of </span><span class="c4">arguments</span><span>&nbsp;with specified types, a </span><span class="c4">return type</span><span class="c3">, and a series of numbered statements.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The values of expressions passed to an algorithm as arguments must match each argument&rsquo;s type.</span></p><h3 class="c20" id="h.zg91f2heefjh"><span class="c10">Scope</span></h3><p class="c2"><span>Algorithms have the same scope behavior as constants; an algorithm can be called inside of itself to implement recursive algorithms.</span></p><p class="c2"><span>Arguments have the same scope behaviors as regular variables; as such, two arguments </span><span class="c5">cannot</span><span class="c3">&nbsp;have the same name.</span></p><h3 class="c20" id="h.u3sgphn82kjm"><span class="c10">Void and Discard</span></h3><p class="c2"><span class="c1">&#10216;discard&#10217; &rarr; &ldquo;Discard&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;period&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>Algorithms have one </span><span class="c4">special data type</span><span>&nbsp;that can be used only as the return type: </span><span class="c4">void</span><span>. A void value has no value literal. A void value can be generated by an empty return statement inside an algorithm with a void return type, or a </span><span class="c4">void algorithm</span><span class="c3">.</span></p><p class="c2"><span>The value of an expression can be thrown away with a discard statement. This is most useful for calling void algorithms, as </span><span class="c5">nothing</span><span class="c3">&nbsp;can be done with void values otherwise.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Void algorithms are useful for specifying side effects, such as printing to standard output.</span></p><h3 class="c20" id="h.rroond5b3c5u"><span class="c10">Control Flow</span></h3><p class="c2"><span>Control flow can modify the execution order of statements in algorithms depending on the value of expressions. A series of statements inside of a control flow statement is known as a </span><span class="c4">block</span><span>. When inside a block, you must </span><span class="c4">indent</span><span class="c3">&nbsp;all statements inside that block. For example:</span></p><p class="c2 c9"><span class="c16">1. If true,</span><span>&nbsp;// zero levels of indentation</span></p><p class="c2 c9"><span class="c16">1.1. While true,</span><span class="c3">&nbsp;// one level of indentation</span></p><p class="c2 c9"><span class="c16">1.1.1. Return. </span><span>// two levels of indentation</span></p><p class="c2 c9"><span class="c16">2. Otherwise, </span><span>// zero levels of indentation</span></p><p class="c2 c9"><span class="c16">2.1 Pass. </span><span>// two levels of indentation</span></p><p class="c0 c9"><span class="c1"></span></p><h4 class="c11" id="h.o6hykls1ruzc"><span class="c15">If-Otherwise</span></h4><p class="c2"><span class="c1">&#10216;if&#10217; &rarr; &ldquo;If&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;comma&#10217;;</span></p><p class="c2"><span class="c1">&#10216;otherwise&#10217; &rarr; &ldquo;Otherwise&rdquo; &#10216;comma&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>If the expression of an </span><span class="c4">if statement</span><span>, known as its </span><span class="c4">condition</span><span>, evaluates to </span><span class="c16">true</span><span>, the if block and </span><span class="c5">only</span><span>&nbsp;the if block is executed. Otherwise, the block of the </span><span class="c4">otherwise</span><span class="c3">&nbsp;statement is executed. This is useful for representing branches in logic.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>An otherwise statement </span><span class="c5">must</span><span>&nbsp;come immediately after an if statement.</span></p><h4 class="c11" id="h.832mhy46mb5v"><span class="c15">Pass</span></h4><p class="c2"><span class="c1">&#10216;pass&#10217; &rarr; &ldquo;Pass&rdquo; &#10216;period&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">This statement does nothing. Use it when you only care about only the if or otherwise case of an if-otherwise statement.</span></p><h4 class="c11" id="h.px9cinrui3kr"><span class="c15">While</span></h4><p class="c2"><span class="c3">&#10216;while&#10217; &rarr; &ldquo;While&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;comma&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The block of a </span><span class="c4">while</span><span>&nbsp;statement is continuously executed while its condition evaluates to </span><span class="c16">true</span><span>.</span></p><h4 class="c11" id="h.yws6xrzw4du"><span class="c15">Return</span></h4><p class="c2"><span class="c16">&#10216;return&#10217; &rarr; &ldquo;Return&rdquo; (&#10216;space&#10217; &#10216;expression&#10217;)? &#10216;period&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Return statements halt the execution of an algorithm, evaluate the expression passed, and pass it up to the algorithm caller. The algorithm call expression will then evaluate to the value returned.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>An algorithm </span><span class="c5">must</span><span class="c3">&nbsp;have a return statement at the end of all branches. Either</span></p><ul class="c19 lst-kix_bmrobk6u7wxi-0 start"><li class="c2 c12 c9 li-bullet-0"><span>the </span><span class="c4">last unindented statement</span><span class="c3">&nbsp;in an algorithm is a return statement, or</span></li><li class="c2 c12 c9 li-bullet-0"><span>the last statements in the if and otherwise blocks of an if-otherwise statement or the block of a while statement are return statements if said statements are the last unindented in an algorithm.</span></li></ul><h2 class="c13" id="h.x0ur8e577smd"><span class="c8">Expressions</span></h2><p class="c2"><span class="c1">&#10216;expression&#10217; &rarr; &#10216;operation&#10217; | &#10216;algorithm call&#10217; | &#10216;value&#10217; | &#10216;variable&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>Expressions are used to represent values.</span></p><h3 class="c20" id="h.phy4y4edt6ec"><span class="c10">Value Literals</span></h3><p class="c2"><span>A value can be created as an expression by rendering its literal; see the </span><span class="c16">&#10216;integer&#10217;</span><span>&nbsp;and </span><span class="c16">&#10216;boolean&#10217;</span><span>&nbsp;rules.</span></p><h3 class="c20" id="h.26bg0koo1rwe"><span class="c10">Variables</span></h3><p class="c2"><span>The value a variable contains can later be retrieved with a variable expression that contains its name; see the </span><span class="c16">&#10216;variable&#10217;</span><span>&nbsp;rule.</span></p><h3 class="c20" id="h.3fwfs2ep5zda"><span class="c10">Operations</span></h3><p class="c2"><span class="c1">&#10216;operation&#10217; &rarr; &#10216;unary operation&#10217; | &#10216;binary operation&#10217;;</span></p><p class="c2"><span class="c1">&#10216;unary operation&#10217; &rarr; &#10216;negation&#10217; | &#10216;not&#10217;;</span></p><p class="c2"><span class="c1">&#10216;binary operation&#10217; &rarr; &#10216;addition&#10217; | &#10216;subtraction&#10217; | &#10216;multiplication&#10217; | &#10216;division&#10217; | &#10216;modulo&#10217; | &#10216;and&#10217; | &#10216;or&#10217; | &#10216;greater than or equal to&#10217; | &#10216;greater than&#10217; | &#10216;less than or equal to&#10217; | &#10216;less than&#10217; | &#10216;equality&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">Operations enable the manipulation of the standard data types. Binary operators, like addition, take two expressions, while unary operators take one.</span></p><p class="c2"><span>Operators in Gorr are evaluated from left to right; there is no operator precedence.</span></p><h4 class="c11" id="h.nsy44xnwrh8r"><span class="c15">Arithmetic</span></h4><p class="c2"><span class="c1">&#10216;negation&#10217; &rarr; &ldquo;the negation of&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#10216;addition&#10217; &rarr; &ldquo;the addition of&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;and&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;subtraction&#10217; &rarr; &ldquo;the subtraction of&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;from&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;multiplication&#10217; &rarr; &ldquo;the multiplication of&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;by&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;multiplication&#10217; &rarr; &ldquo;the division of&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;by&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;modulo&#10217; &rarr; &ldquo;the modulo of&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;by&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>These operators implement the standard arithmetic operators; they take in integers and evaluate to integers. Because Gorr only has integers, when dividing, the remainder is disposed of; it can be retrieved with the modulo.</span></p><h4 class="c11" id="h.lek785w19qu6"><span class="c15">Boolean Algebra</span></h4><p class="c2"><span class="c1">&#10216;not&#10217; &rarr; &ldquo;not&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#10216;and&#10217; &rarr; &ldquo;both&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;and&rdquo; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;or&#10217; &rarr; &ldquo;either&rdquo; &#10216;space&#10217; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;or&rdquo; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>These operators implement the standard Boolean operators; they take in Booleans and evaluate to Booleans.</span></p><h4 class="c11" id="h.nhqxa5fug7pu"><span class="c15">Equality and Inequality</span></h4><p class="c2"><span class="c1">&#10216;equality&#10217; &rarr; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;is equal to&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c1"></span></p><p class="c2"><span class="c1">&#10216;greater than or equal to&#10217; &rarr; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;is greater than or equal to&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;greater than&#10217; &rarr; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;is greater than&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;less than or equal to&#10217; &rarr; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;is less than or equal to&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c2"><span class="c1">&#10216;less than&#10217; &rarr; &#10216;expression&#10217; &#10216;space&#10217; &ldquo;is less than&rdquo; &#10216;space&#10217; &#10216;expression&#10217;;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The equivalence operator evaluates to </span><span class="c16">true</span><span class="c3">&nbsp;if both expressions evaluate to the same value.</span></p><p class="c2"><span>Both expressions </span><span class="c5">must</span><span class="c3">&nbsp;be the same type.</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>The inequality operators work as one would expect: they take in integers and evaluate to booleans.</span></p><h3 class="c20" id="h.zi0h5stxh73f"><span>Algorithm Call</span></h3><p class="c2"><span class="c1">&#10216;algorithm call&#10217; &rarr; &ldquo;call&rdquo; &#10216;space&#10217; &#10216;variable&#10217; (&ldquo;arguments&rdquo; &#10216;space&#10217; &#10216;expression&#10217; (&#10216;comma&#10217; &#10216;space&#10217; &#10216;expression&#10217;)*)?;</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span>This expression takes the name of an algorithm along with a list of specified arguments, runs the algorithm with said arguments, and evaluates to its return value.</span></p><h1 class="c17" id="h.abi33gja9fdx"><span class="c6">Examples</span></h1><h2 class="c13" id="h.4l1u622bdkmi"><span class="c8">Factorial</span></h2><p class="c2"><span class="c3">The algorithm [[ factorial ]], with the signature integer [[a]] returns integer, does the following:</span></p><p class="c2"><span class="c3">1. If either [[a]] is equal to 0 or [[a]] is equal to 1,</span></p><p class="c2"><span class="c3">1.1. Return 1.</span></p><p class="c2"><span class="c3">2. Otherwise,</span></p><p class="c2"><span class="c3">2.1. Return the multiplication of [[a]] by call [[factorial]] arguments the subtraction of 1 from [[a]].</span></p><h2 class="c13" id="h.1rulurusfydk"><span>Greatest Common Denominator and </span><span>Least Common Multiple</span></h2><p class="c2"><span class="c3">The algorithm [[ absolute value ]] with the signature integer [[ a ]] returns integer, does the following:</span></p><p class="c2"><span class="c3">1. If [[ a ]] is greater than or equal to 0,</span></p><p class="c2 c21"><span class="c3">1.1. Return [[ a ]].</span></p><p class="c2"><span class="c3">2. Otherwise,</span></p><p class="c2 c21"><span class="c3">2.1. Return the negation of [[ a ]].</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">The algorithm [[ greatest common denominator ]] with the signature integer [[ u ]], integer [[ v ]] returns integer, does the following:</span></p><p class="c2"><span class="c3">1. While [[ v ]] is greater than 0,</span></p><p class="c2 c21"><span class="c3">1.1. The integer [[ previous u ]] is [[ u ]].</span></p><p class="c2 c21"><span class="c3">1.2. Set [[ u ]] to [[ v ]].</span></p><p class="c2 c21"><span class="c3">1.3. Set [[ v ]] to the modulo of [[ previous u ]] by [[ v ]].</span></p><p class="c2"><span class="c3">2. Return call [[ absolute value ]] arguments [[ u ]].</span></p><p class="c0"><span class="c3"></span></p><p class="c2"><span class="c3">The algorithm [[ least common multiple ]] with the signature integer [[ u ]], integer [[ v ]] returns integer, does the following:</span></p><p class="c2"><span class="c3">1. If &nbsp;both [[ u ]] is greater than 0 and [[ a ]] is greater than 0,</span></p><p class="c2 c21"><span class="c3">1.1. Return the division of call [[ absolute value ]] arguments the multiplication of [[ a ]] by [[ b ]] by call [[ greatest common denominator ]] arguments [[ u ]], [[ v ]].</span></p><p class="c2"><span class="c3">2. Otherwise,</span></p><p class="c2 c21"><span class="c3">2.1. Return 0.</span></p><hr class="c18"><div><p class="c24"><a href="#ftnt_ref1" id="ftnt1">[1]</a><span class="c14">&nbsp;In this specification, </span><span class="c4 c14">data type</span><span class="c14">&nbsp;will usually be shortened to just </span><span class="c4 c14">type</span><span class="c14">.</span></p></div></body></html>